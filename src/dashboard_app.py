import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime
from pathlib import Path

# ==========================================
# 1. CONFIG & DATA LOADING
# ==========================================
st.set_page_config(page_title="AVA Strategic Dashboard", layout="wide")

# --- Define paths relative to the script location for robustness ---
PROJECT_ROOT = Path(__file__).parent.parent
RESULTS_DIR = PROJECT_ROOT / "results" / "gemini_classification"

# The file generated by your classification script
DATA_FILE = RESULTS_DIR / "ava_test_results_400_rows.csv"

@st.cache_data
def load_data(file_path):
    # Load your classified data
    df = pd.read_csv(file_path)
    
    # --- PRE-PROCESSING ---
    
    # 1. Date Parsing
    df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
    
    # 2. Coverage Score Calculation (The Supply Logic)
    def get_coverage(row):
        # Logic: 0=Gap, 1=Shallow, 2=Strong
        if str(row.get('Abstention')) == 'True' or row.get('num_documents', 0) == 0:
            return 0.0
        
        flagships = ['WDR', 'Global Economic Prospects', 'Poverty Assessment', 'CEM']
        titles = str(row.get('Document titles', '')).lower()
        
        if row.get('num_documents', 0) >= 4 or any(x.lower() in titles for x in flagships):
            return 2.0
        return 1.0

    df['coverage_score'] = df.apply(get_coverage, axis=1)
    
    # 3. Fill NaNs for safe plotting
    df['L0_cross_cutting'] = df['L0_cross_cutting'].fillna('None')
    df['L1_theme'] = df['L1_theme'].fillna('Unclassified')
    df['primary_pillar'] = df['primary_pillar'].fillna('Unknown')
    df['region'] = df['region'].fillna('Unknown').astype(str)
    df['L2_sub_topic'] = df['L2_sub_topic'].fillna('N/A')
    df['L3_standardized_topic'] = df['L3_standardized_topic'].fillna('N/A')
    
    return df

try:
    df_raw = load_data(DATA_FILE)
except FileNotFoundError:
    st.error(f"File '{DATA_FILE}' not found. Please ensure the classification script has run and the file exists.")
    st.stop()

# ==========================================
# 2. SIDEBAR FILTERS (Global Scope)
# ==========================================
st.sidebar.header("ðŸ” Global Filters")

# A. Date Range
min_date = df_raw['Date'].min()
max_date = df_raw['Date'].max()
start_date, end_date = st.sidebar.date_input(
    "Date Range",
    [min_date, max_date],
    min_value=min_date,
    max_value=max_date
)

# B. Region Filter
all_regions = ['All'] + sorted([r for r in df_raw['region'].unique() if r not in ['Global', 'Unknown']])
selected_region = st.sidebar.selectbox("Country/Region", all_regions)

# C. Cross-Cutting Filter (L0)
l0_options = ['All'] + sorted([x for x in df_raw['L0_cross_cutting'].unique() if x != 'None'])
selected_l0 = st.sidebar.selectbox("Cross-Cutting Lens (L0)", l0_options)

# D. Abstention Filter
abstention_filter = st.sidebar.radio("Query Status", ["All Queries", "Only Unanswered (Abstentions)"])

# --- APPLY FILTERS ---
# Convert filter dates to timezone-aware (UTC) to match the DataFrame's 'Date' column
start_date_utc = pd.to_datetime(start_date).tz_localize('UTC')
end_date_utc = pd.to_datetime(end_date).tz_localize('UTC')

mask = (df_raw['Date'] >= start_date_utc) & (df_raw['Date'] <= end_date_utc)

if selected_region != 'All':
    mask = mask & (df_raw['region'] == selected_region)

if selected_l0 != 'All':
    mask = mask & (df_raw['L0_cross_cutting'] == selected_l0)

if abstention_filter == "Only Unanswered (Abstentions)":
    mask = mask & (df_raw['Abstention'].astype(str) == 'True')

df = df_raw[mask].copy()
df_valid = df[df['relevance'] == 'Valid'].copy() # Most charts only use Valid queries

# ==========================================
# 3. DASHBOARD TABS
# ==========================================
tab1, tab2, tab3, tab4 = st.tabs([
    "ðŸ“Š Strategic Overview (VP)", 
    "ðŸŽ¯ Demand vs. Supply (Product)", 
    "ðŸ”Ž Knowledge Explorer (Research)",
    "âš™ï¸ System Health (Admin)"
])

# --- TAB 1: STRATEGIC OVERVIEW ---
with tab1:
    st.subheader(f"Strategic Alignment: {len(df_valid)} Valid Queries")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.markdown("**The Bank's Portfolio (Sunburst)**")
        
        # --- Robustness Fix for Sunburst ---
        # Filter data to ensure a clean hierarchy for the chart.
        # This prevents the chart from breaking on drill-down.
        sunburst_df = df_valid[(df_valid['primary_pillar'] != 'Unknown') & (df_valid['L1_theme'] != 'Unclassified')].copy()

        # --- Robust Hierarchy Creation ---
        # Instead of creating a 'path' column, we create clean hierarchical columns
        # that px.sunburst can use directly. This is the idiomatic way.
        hierarchy_cols = ['primary_pillar', 'L1_theme', 'L2_sub_topic', 'L3_standardized_topic']
        
        # Create a copy to avoid SettingWithCopyWarning
        clean_sunburst_df = sunburst_df[hierarchy_cols].copy()
        
        # Replace invalid values with a placeholder that won't be plotted
        for col in hierarchy_cols:
            clean_sunburst_df[col] = clean_sunburst_df[col].replace(['N/A', 'Unclassified'], None)
            
        # Add the count for the values parameter
        clean_sunburst_df['count'] = 1
        
        sunburst_df['count'] = 1 # Use a count for sizing

        fig_sun = px.sunburst(
            clean_sunburst_df,
            path=hierarchy_cols, # Pass the list of column names
            values='count',
            maxdepth=2, # Start with the first two levels visible for clarity
            color='primary_pillar', # Color by the top-level category
            color_discrete_map={
                'People': '#E67E22', 'Planet': '#27AE60', 'Prosperity': '#2980B9', 
                'Infrastructure': '#8E44AD', 'Digital': '#C0392B'
            }
        )
        fig_sun.update_layout(height=600)
        st.plotly_chart(fig_sun, use_container_width=True)
        
    with col2:
        st.markdown("**User Intent Breakdown**")
        intent_counts = df_valid['intent'].value_counts().reset_index()
        intent_counts.columns = ['Intent', 'Count']
        fig_donut = px.pie(
            intent_counts, values='Count', names='Intent', hole=0.4,
            color_discrete_sequence=px.colors.sequential.RdBu
        )
        st.plotly_chart(fig_donut, use_container_width=True)
        
        st.markdown("---")
        st.markdown("**Top Cross-Cutting Themes**")
        l0_counts = df_valid[df_valid['L0_cross_cutting'] != 'None']['L0_cross_cutting'].value_counts()
        st.bar_chart(l0_counts)

# --- TAB 2: DEMAND VS SUPPLY (The GAP Matrix) ---
with tab2:
    st.subheader("Demand vs. Supply: Identify Content Gaps")
    st.info("Each bubble is a Standardized Research Question (L3). Size = Volume of Queries.")
    
    # Aggregating Data by L3 Topic
    bubble_data = df_valid.groupby('L3_standardized_topic').agg({
        'Query_en': 'count',                 # Volume (X-axis)
        'coverage_score': 'mean',            # Quality (Y-axis)
        'primary_pillar': 'first',           # Color
        'L1_theme': 'first'                  # Hover info
    }).reset_index()
    
    bubble_data = bubble_data.rename(columns={'Query_en': 'Demand Volume', 'coverage_score': 'Avg Coverage'})
    
    # Filter out noise (single queries) for cleaner chart
    bubble_data = bubble_data[bubble_data['Demand Volume'] > 1] 

    fig_bubble = px.scatter(
        bubble_data,
        x="Demand Volume",
        y="Avg Coverage",
        size="Demand Volume",
        color="primary_pillar",
        hover_name="L3_standardized_topic",
        hover_data=["L1_theme"],
        size_max=20, # Further reduce the maximum bubble size for better readability
        range_y=[-0.2, 2.2],
        title="Gap Analysis Matrix (Hover for details)"
    )
    
    # Add Quadrant Lines
    fig_bubble.add_hline(y=1.0, line_dash="dash", line_color="gray", annotation_text="Adequate Coverage")
    fig_bubble.add_vline(x=bubble_data['Demand Volume'].median(), line_dash="dash", line_color="gray")
    
    st.plotly_chart(fig_bubble, use_container_width=True)
    
    # The "Red Alert" Table
    st.subheader("ðŸš¨ Critical Gaps (High Demand, Low Coverage)")
    critical_gaps = bubble_data[
        (bubble_data['Avg Coverage'] < 0.8) & 
        (bubble_data['Demand Volume'] > bubble_data['Demand Volume'].median())
    ].sort_values('Demand Volume', ascending=False)
    
    st.dataframe(critical_gaps[['L3_standardized_topic', 'Demand Volume', 'Avg Coverage', 'primary_pillar']])

# --- TAB 3: KNOWLEDGE EXPLORER ---
with tab3:
    st.subheader("Drill Down by Theme")
    
    # Filter by L1 Theme
    selected_l1 = st.selectbox("Select a Sector (L1 Theme):", sorted(df_valid['L1_theme'].unique()))
    
    subset_l1 = df_valid[df_valid['L1_theme'] == selected_l1]
    
    # Bar Chart of Top L3 Questions
    top_l3 = subset_l1['L3_standardized_topic'].value_counts().head(15).sort_values(ascending=True)
    
    col3, col4 = st.columns([2, 1])
    
    with col3:
        fig_bar = px.bar(
            x=top_l3.values,
            y=top_l3.index,
            orientation='h',
            labels={'x': 'Query Count', 'y': 'Research Question'},
            title=f"Top Questions in {selected_l1}"
        )
        st.plotly_chart(fig_bar, use_container_width=True)
        
    with col4:
        st.markdown(f"**{selected_l1} Stats**")
        st.metric("Total Queries", len(subset_l1))
        st.metric("Avg Coverage", f"{subset_l1['coverage_score'].mean():.2f}/2.0")
        st.metric("Abstention Rate", f"{(subset_l1['Abstention'].astype(str)=='True').mean()*100:.1f}%")

    # Detail View
    st.markdown("### ðŸ“„ Latest Query Details")
    st.dataframe(
        subset_l1[['Date', 'Query_en', 'L3_standardized_topic', 'intent', 'region', 'coverage_score']]
        .sort_values('Date', ascending=False).head(50)
    )

# --- TAB 4: SYSTEM HEALTH ---
with tab4:
    st.subheader("System Diagnostics")
    
    c1, c2 = st.columns(2)
    
    with c1:
        st.markdown("**Relevance Classification Breakdown**")
        rel_counts = df['relevance'].value_counts()
        fig_rel = px.bar(rel_counts, title="Valid vs. OOS/Noise")
        st.plotly_chart(fig_rel, use_container_width=True)
        
        st.warning("Monitor 'OOS_Context_Missing'. High numbers mean users are trying to summarize files without uploading them correctly.")

    with c2:
        st.markdown("**Abstention Analysis (Valid Queries Only)**")
        abstention_rate = df_valid['Abstention'].astype(str).value_counts(normalize=True)
        fig_abs = px.pie(names=abstention_rate.index, values=abstention_rate.values, title="Success vs. Abstention Rate")
        st.plotly_chart(fig_abs, use_container_width=True)

    st.markdown("### ðŸ“‰ Failed Queries Log (Abstentions)")
    st.dataframe(
        df_valid[df_valid['Abstention'].astype(str) == 'True'][['Date', 'Query_en', 'L1_theme', 'L3_standardized_topic']]
    )